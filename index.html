import React, { useEffect, useRef, useState } from 'react';
import * as THREE from 'three';

export default function RotationVisualization() {
  const mountRef = useRef(null);
  const sceneRef = useRef(null);
  const cameraRef = useRef(null);
  const rendererRef = useRef(null);
  const cubeRef = useRef(null);
  const axesGroupRef = useRef(null);
  
  const [rotationAxis, setRotationAxis] = useState('x');
  const [rotationAngle, setRotationAngle] = useState(0);
  const [rotationSpeed, setRotationSpeed] = useState(0);
  const [centerX, setCenterX] = useState(0);
  const [centerY, setCenterY] = useState(0);
  const [centerZ, setCenterZ] = useState(0);
  const [rotationDirection, setRotationDirection] = useState('clockwise');

  useEffect(() => {
    if (!mountRef.current) return;

    // Setup scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    sceneRef.current = scene;

    // Setup camera
    const width = mountRef.current.clientWidth;
    const height = mountRef.current.clientHeight;
    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    camera.position.set(8, 8, 8);
    camera.lookAt(0, 0, 0);
    cameraRef.current = camera;

    // Setup renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, height);
    mountRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // Create grid
    const gridHelper = new THREE.GridHelper(10, 10, 0x888888, 0xcccccc);
    scene.add(gridHelper);

    // Create main axes (always visible)
    const axesHelper = new THREE.AxesHelper(6);
    scene.add(axesHelper);

    // Create cube
    const geometry = new THREE.BoxGeometry(2, 2, 2);
    const material = new THREE.MeshPhongMaterial({ 
      color: 0x8b3dff,
      transparent: true,
      opacity: 0.9
    });
    const cube = new THREE.Mesh(geometry, material);
    
    // Add edges to cube
    const edges = new THREE.EdgesGeometry(geometry);
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
    const wireframe = new THREE.LineSegments(edges, lineMaterial);
    cube.add(wireframe);
    
    scene.add(cube);
    cubeRef.current = cube;

    // Create rotation axis group
    const axesGroup = new THREE.Group();
    scene.add(axesGroup);
    axesGroupRef.current = axesGroup;

    // Add lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
    directionalLight.position.set(5, 10, 5);
    scene.add(directionalLight);

    // Animation loop
    let animationId;
    const animate = () => {
      animationId = requestAnimationFrame(animate);
      if (rendererRef.current && sceneRef.current && cameraRef.current) {
        rendererRef.current.render(sceneRef.current, cameraRef.current);
      }
    };
    animate();

    // Handle resize
    const handleResize = () => {
      if (mountRef.current) {
        const width = mountRef.current.clientWidth;
        const height = mountRef.current.clientHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
      }
    };
    window.addEventListener('resize', handleResize);

    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize);
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      if (mountRef.current && rendererRef.current && rendererRef.current.domElement) {
        try {
          mountRef.current.removeChild(rendererRef.current.domElement);
        } catch (e) {
          console.log('Cleanup error:', e);
        }
      }
      if (geometry) geometry.dispose();
      if (material) material.dispose();
      if (rendererRef.current) rendererRef.current.dispose();
    };
  }, []);

  // Update rotation center and axis
  useEffect(() => {
    if (!cubeRef.current || !axesGroupRef.current) return;

    const cube = cubeRef.current;
    const axesGroup = axesGroupRef.current;

    // Clear previous axes
    while (axesGroup.children.length > 0) {
      axesGroup.remove(axesGroup.children[0]);
    }

    // Set rotation center
    cube.position.set(centerX, centerY, centerZ);

    // Create rotation axis indicator
    const arrowLength = 5;
    let direction = new THREE.Vector3();
    let color = 0x00ff00;

    switch (rotationAxis) {
      case 'x':
        direction = new THREE.Vector3(1, 0, 0);
        color = 0xff0000;
        break;
      case 'y':
        direction = new THREE.Vector3(0, 1, 0);
        color = 0x00ff00;
        break;
      case 'z':
        direction = new THREE.Vector3(0, 0, 1);
        color = 0x0000ff;
        break;
    }

    const origin = new THREE.Vector3(centerX, centerY, centerZ);
    const arrowHelper = new THREE.ArrowHelper(direction, origin, arrowLength, color, 1, 0.5);
    axesGroup.add(arrowHelper);

    // Add opposite direction arrow
    const arrowHelper2 = new THREE.ArrowHelper(
      direction.clone().multiplyScalar(-1),
      origin,
      arrowLength,
      color,
      1,
      0.5
    );
    axesGroup.add(arrowHelper2);

  }, [centerX, centerY, centerZ, rotationAxis]);

  // Update rotation
  useEffect(() => {
    if (!cubeRef.current) return;

    const cube = cubeRef.current;
    const angleInRadians = (rotationAngle * Math.PI) / 180;
    const direction = rotationDirection === 'clockwise' ? -1 : 1;

    // Reset rotation
    cube.rotation.set(0, 0, 0);

    // Apply rotation based on axis
    switch (rotationAxis) {
      case 'x':
        cube.rotation.x = angleInRadians * direction;
        break;
      case 'y':
        cube.rotation.y = angleInRadians * direction;
        break;
      case 'z':
        cube.rotation.z = angleInRadians * direction;
        break;
    }
  }, [rotationAxis, rotationAngle, rotationDirection]);

  // Auto rotation
  useEffect(() => {
    if (rotationSpeed === 0) return;

    const interval = setInterval(() => {
      setRotationAngle(prev => (prev + rotationSpeed) % 360);
    }, 50);

    return () => clearInterval(interval);
  }, [rotationSpeed]);

  return (
    <div className="w-full h-screen bg-gradient-to-br from-purple-50 to-blue-50 p-6">
      <div className="max-w-7xl mx-auto h-full flex flex-col gap-6">
        {/* Header */}
        <div className="text-center">
          <h1 className="text-4xl font-bold text-purple-700 mb-2">
            Visualisasi 3D Rotasi Transformasi Geometri
          </h1>
          <p className="text-gray-600">
            Eksplorasi interaktif transformasi rotasi objek 3D dengan berbagai parameter
          </p>
        </div>

        <div className="flex-1 grid grid-cols-1 lg:grid-cols-2 gap-6 min-h-0">
          {/* 3D Visualization */}
          <div className="bg-white rounded-2xl shadow-xl p-6">
            <h2 className="text-2xl font-bold text-purple-700 mb-4">Visualisasi 3D Rotasi</h2>
            <div 
              ref={mountRef} 
              className="w-full h-[500px] rounded-xl border-2 border-purple-200"
            />
          </div>

          {/* Controls Panel */}
          <div className="bg-white rounded-2xl shadow-xl p-6 overflow-y-auto">
            <h2 className="text-2xl font-bold text-purple-700 mb-6">Parameter Rotasi</h2>
            
            {/* Rotation Angle */}
            <div className="mb-8">
              <label className="block text-lg font-semibold text-gray-700 mb-3">
                Sudut Rotasi: {rotationAngle}°
              </label>
              <input
                type="range"
                min="0"
                max="360"
                value={rotationAngle}
                onChange={(e) => setRotationAngle(Number(e.target.value))}
                className="w-full h-3 bg-purple-200 rounded-lg appearance-none cursor-pointer accent-purple-600"
              />
              <div className="flex justify-between text-sm text-gray-500 mt-2">
                <span>0°</span>
                <span>180°</span>
                <span>360°</span>
              </div>
            </div>

            {/* Rotation Axis */}
            <div className="mb-8">
              <label className="block text-lg font-semibold text-gray-700 mb-3">
                Sumbu Rotasi
              </label>
              <select
                value={rotationAxis}
                onChange={(e) => setRotationAxis(e.target.value)}
                className="w-full p-4 text-lg border-2 border-purple-200 rounded-lg focus:outline-none focus:border-purple-500"
              >
                <option value="x">Sumbu X (Merah)</option>
                <option value="y">Sumbu Y (Hijau)</option>
                <option value="z">Sumbu Z (Biru)</option>
              </select>
            </div>

            {/* Rotation Direction */}
            <div className="mb-8">
              <label className="block text-lg font-semibold text-gray-700 mb-3">
                Arah Rotasi
              </label>
              <select
                value={rotationDirection}
                onChange={(e) => setRotationDirection(e.target.value)}
                className="w-full p-4 text-lg border-2 border-purple-200 rounded-lg focus:outline-none focus:border-purple-500"
              >
                <option value="counterclockwise">Berlawanan Arah Jarum Jam</option>
                <option value="clockwise">Searah Jarum Jam</option>
              </select>
            </div>

            {/* Rotation Speed */}
            <div className="mb-8">
              <label className="block text-lg font-semibold text-gray-700 mb-3">
                Kecepatan Rotasi: {rotationSpeed}°/tick
              </label>
              <input
                type="range"
                min="0"
                max="5"
                step="0.5"
                value={rotationSpeed}
                onChange={(e) => setRotationSpeed(Number(e.target.value))}
                className="w-full h-3 bg-purple-200 rounded-lg appearance-none cursor-pointer accent-purple-600"
              />
              <div className="flex justify-between text-sm text-gray-500 mt-2">
                <span>Berhenti</span>
                <span>Cepat</span>
              </div>
            </div>

            {/* Rotation Center */}
            <div className="border-t-2 border-purple-100 pt-6">
              <h3 className="text-xl font-bold text-purple-700 mb-6">Pusat Rotasi</h3>
              
              <div className="mb-6">
                <label className="block text-lg font-semibold text-gray-700 mb-3">
                  Pusat X: {centerX.toFixed(1)}
                </label>
                <input
                  type="range"
                  min="-5"
                  max="5"
                  step="0.5"
                  value={centerX}
                  onChange={(e) => setCenterX(Number(e.target.value))}
                  className="w-full h-3 bg-red-200 rounded-lg appearance-none cursor-pointer accent-red-600"
                />
              </div>

              <div className="mb-6">
                <label className="block text-lg font-semibold text-gray-700 mb-3">
                  Pusat Y: {centerY.toFixed(1)}
                </label>
                <input
                  type="range"
                  min="-5"
                  max="5"
                  step="0.5"
                  value={centerY}
                  onChange={(e) => setCenterY(Number(e.target.value))}
                  className="w-full h-3 bg-green-200 rounded-lg appearance-none cursor-pointer accent-green-600"
                />
              </div>

              <div className="mb-6">
                <label className="block text-lg font-semibold text-gray-700 mb-3">
                  Pusat Z: {centerZ.toFixed(1)}
                </label>
                <input
                  type="range"
                  min="-5"
                  max="5"
                  step="0.5"
                  value={centerZ}
                  onChange={(e) => setCenterZ(Number(e.target.value))}
                  className="w-full h-3 bg-blue-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
                />
              </div>
            </div>

            {/* Reset Button */}
            <button
              onClick={() => {
                setRotationAngle(0);
                setRotationSpeed(0);
                setCenterX(0);
                setCenterY(0);
                setCenterZ(0);
                setRotationAxis('x');
                setRotationDirection('counterclockwise');
              }}
              className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-4 px-6 rounded-lg transition-colors duration-200 text-lg mt-6"
            >
              Reset Semua Parameter
            </button>
          </div>
        </div>

        {/* Info Panel */}
        <div className="bg-white rounded-2xl shadow-xl p-6">
          <h3 className="text-lg font-bold text-purple-700 mb-3">Informasi</h3>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
            <div className="bg-purple-50 p-4 rounded-lg">
              <p className="font-semibold text-purple-700">Transformasi Saat Ini:</p>
              <p className="text-gray-700">Rotasi {rotationAngle}° pada sumbu {rotationAxis.toUpperCase()}</p>
            </div>
            <div className="bg-purple-50 p-4 rounded-lg">
              <p className="font-semibold text-purple-700">Pusat Rotasi:</p>
              <p className="text-gray-700">({centerX.toFixed(1)}, {centerY.toFixed(1)}, {centerZ.toFixed(1)})</p>
            </div>
            <div className="bg-purple-50 p-4 rounded-lg">
              <p className="font-semibold text-purple-700">Arah:</p>
              <p className="text-gray-700">
                {rotationDirection === 'clockwise' ? 'Searah Jarum Jam' : 'Berlawanan Arah Jarum Jam'}
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
